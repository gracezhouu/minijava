options {  STATIC = false;  //JAVA_UNICODE_ESCAPE = true;}PARSER_BEGIN(MiniJavaParser)package com.munkhbat.minijava.parser;import com.munkhbat.minijava.ast.*;import com.munkhbat.minijava.visitor.*;public class MiniJavaParser {}PARSER_END(MiniJavaParser)SPECIAL_TOKEN:{ <SPACES: ([" ", "\t", "\n", "\r", "\f"])+ > }MORE: { <"/*"> : IN_BLOCK_COMMENT }<IN_BLOCK_COMMENT> MORE: { <~[]> }<IN_BLOCK_COMMENT> SPECIAL_TOKEN: { <BLOCK_COMMENT: "*/"> : DEFAULT }SPECIAL_TOKEN: {    <LINE_COMMENT: "//" (~["\n", "\r"])* ("\n" | "\r\n" | "\r")?>}TOKEN: {  < CLASS : "class" >| < LBRACE :"{" >| < PUBLIC : "public" >| < STATIC : "static" >| < VOID : "void" >| < MAIN : "main" >| < LPAREN : "(" >| < STRING : "String" >| < LBRACK : "[" >| < RBRACK : "]" >| < RPAREN : ")" >| < RBRACE : "}" >| < EXTENDS : "extends" >| < SEMICOLON : ";" >| < RETURN : "return" >| < COMMA : "," >| < INT : "int" >| < BOOLEAN : "boolean" >| < ASSIGN : "=" >| < IF : "if" >| < ELSE : "else" >| < WHILE : "while" >| < PRINT : "System.out.println" >| < AND : "&&" >| < LT : "<" >| < PLUS : "+" >| < MINUS : "-" >| < TIMES : "*" >| < DOT : "." >| < LENGTH : "length" >| < TRUE : "true" >| < FALSE : "false" >| < THIS : "this" >| < NEW : "new" >| < EXCLAMATION : "!" >}TOKEN: {    <IDENTIFIER: ["a"-"z", "A"-"Z", "_"] (["a"-"z", "A"-"Z", "_", "0"-"9"])* | "0">}TOKEN: {    <INTEGER_LITERAL: ["1"-"9"] (["0"-"9"])* >}/** * Grammar */Program Program() :{  MainClass mainClass;  ClassDeclList classDeclList;}{  mainClass = MainClass() classDeclList = ClassDeclL()  {    return new Program(mainClass, classDeclList);  }}MainClass MainClass() :{  Statement s;  Token t1, t2;}{  < CLASS > t1 = < IDENTIFIER > < LBRACE > < PUBLIC > <STATIC > < VOID > < MAIN > <LPAREN > < STRING >  < LBRACK > <RBRACK > t2 = < IDENTIFIER > <RPAREN > <LBRACE >  s = Statement()  < RBRACE > < RBRACE >  {    return new MainClass(new Identifier(t1.image), new Identifier(t2.image), s);  }}
ClassDeclList ClassDeclL():{  ClassDeclList classDeclList;  ClassDecl classDecl;}{  classDecl = ClassDecl() classDeclList = ClassDeclL()  {    classDeclList.addElement(classDecl);    return classDeclList;  }|{  return new ClassDeclList();}}ClassDecl ClassDecl():{  VarDeclList varDeclList, varDeclList1;  MethodDeclList methodDeclList, methodDeclList1;  Token t, t1;}{  < CLASS > t = < IDENTIFIER >  (    < LBRACE > varDeclList = VarDeclL() methodDeclList = MethodDeclL() < RBRACE >    {      return new ClassDeclSimple(new Identifier(t.image), varDeclList, methodDeclList);    }  | < EXTENDS > t1 = < IDENTIFIER > < LBRACE > varDeclList1 = VarDeclL() methodDeclList1 = MethodDeclL() < RBRACE >  {    return new ClassDeclExtends(new Identifier(t.image), new Identifier(t1.image), varDeclList1, methodDeclList1);  }  )}VarDecl VarDecl():{  Type typ;  Token t;}{  typ = Type() t = < IDENTIFIER > < SEMICOLON >  {    return new VarDecl(typ, new Identifier(t.image));  }}VarDeclList VarDeclL():{  VarDeclList varDeclList;  VarDecl varDecl;}{  varDecl = VarDecl() varDeclList = VarDeclL()  {    varDeclList.addElement(varDecl);    return varDeclList;  }|{  return new VarDeclList();}}MethodDeclList MethodDeclL():{  MethodDeclList methodDeclList;  MethodDecl medthodDecl;}{  medthodDecl = MethodDecl() methodDeclList = MethodDeclL()  {    methodDeclList.addElement(medthodDecl);    return methodDeclList;  }|{  return new MethodDeclList();}}MethodDecl MethodDecl():{  Type typ;  Token t;  FormalList formalList;  VarDeclList varDeclList = new VarDeclList();  VarDecl varDecl;  StatementList statementList = new StatementList();  Statement s;  Exp exp;}{  < PUBLIC > typ = Type() t = < IDENTIFIER > < LPAREN > formalList = FormalList()  < RPAREN > <LBRACE >  (    LOOKAHEAD(2) varDecl = VarDecl()    {      varDeclList.addElement(varDecl);    }  )*  (    LOOKAHEAD(2) s = Statement()    {      statementList.addElement(s);    }  )*  //statementList = StatementL() < RETURN >  < RETURN > exp = Exp() < SEMICOLON > < RBRACE >  {    return new MethodDecl(typ, new Identifier(t.image), formalList,     varDeclList, statementList, exp);  }}FormalList FormalList():{  Type typ;  FormalList formalList = new FormalList();  Formal formal, formal1;  Token t;}{  typ = Type() t = < IDENTIFIER >  (    formal = FormalRest()  	{    	formalList.addElement(formal);  	}  )*  {    formal1 = new Formal(typ, new Identifier(t.image));    formalList.addElement(formal1);    return formalList;  }|{  return new FormalList();}}Formal FormalRest():{  Type typ;  Token t;}{  < COMMA > typ = Type() t = < IDENTIFIER >  {    return new Formal(typ, new Identifier(t.image));  }}Type Type():{  Token t;}{  LOOKAHEAD(2)< INT > <LBRACK > < RBRACK >  {    return new IntArrayType();  }| LOOKAHEAD(2) < INT >{  return new IntegerType();}| < BOOLEAN >{  return new BooleanType();}| t = < IDENTIFIER >{  return new IdentifierType(t.image);}}Statement Statement() :{	Statement s1, s2, s3, sPrime;	StatementList sl1;	Exp e1, e2, e3, e4, e5, e6, e7;	Token t1;}{  < LBRACE > sl1 = Block() < RBRACE >  {    return new Block(sl1);  }| < IF > <LPAREN > e1 = Exp() < RPAREN > s1 = Statement() < ELSE > s2 = Statement(){  return new If(e1, s1, s2);}| < WHILE> <LPAREN > e2 = Exp() < RPAREN > s3 = Statement(){  return new While(e2, s3);}| < PRINT> <LPAREN > e4 = Exp() < RPAREN > < SEMICOLON >{  return new Print(e4);}| t1 = < IDENTIFIER >(  < ASSIGN > e5 = Exp() < SEMICOLON >  {    return new Assign (new Identifier(t1.image), e5);  }| < LBRACK > e6 = Exp() < RBRACK > < ASSIGN > e7 = Exp() < SEMICOLON >{  return new ArrayAssign(new Identifier(t1.image), e6, e7);})}StatementList Block():{  StatementList sl = new StatementList();  Statement s;}{  	(  	  s = Statement()  	  {  	    sl.addElement(s);  	  }  	)*  	{  	  return sl;  	}}//Exp Exp():{  Exp e1, e2;}{  e1 = expTerm() e2 = ExpRecursive(e1)  {    return e2;  }}Exp expTerm():{  Token t, t1, t2;  Exp e, e1, e2;}{  t = < INTEGER_LITERAL >  {    return new IntegerLiteral(Integer.parseInt(t.image));  }| < TRUE >{  return new True();}| < FALSE >{  return new False();}| t1 = < IDENTIFIER >{  {    return new IdentifierExp(t1.image);  }}| < THIS >{  return new This();}| < NEW >(  < INT > <LBRACK > e = Exp() < RBRACK >  {    return new NewArray(e);  }| t2 = <IDENTIFIER > < LPAREN> <RPAREN >{  return new NewObject(new Identifier(t2.image));})| < EXCLAMATION > e1 = Exp(){  return new Not(e1);}| < LPAREN> e2 = Exp() <RPAREN >{  return e2;}}Exp ExpRecursive(Exp e1):{  Exp e11, e2, e3;}{  < LBRACK > e11 = Exp() < RBRACK >  {    return new ArrayLookup(e1, e11);  }| < DOT > e2 = ExpMethodCallLength(e1){  return e2;}| e3 = BinOpExp(e1){ return e3; }|{  return e1;}}Exp ExpMethodCallLength(Exp e):{  Token t;ExpList expList;}{  < LENGTH >  {    return new ArrayLength(e);  }| t = < IDENTIFIER > <LPAREN > expList = ExpList() < RPAREN >{  return new Call(e, new Identifier(t.image), expList);}}Exp BinOpExp(Exp e1):{  Exp e2;}{  < AND > e2 = Exp()  {    return new And(e1, e2);  }| < LT > e2 = Exp(){  return new LessThan(e1, e2);}| < PLUS > e2 = Exp(){  return new Plus(e1, e2);}| < MINUS > e2 = Exp(){  return new Minus(e1, e2);}| < TIMES > e2 = Exp(){  return new Times(e1, e2);}}ExpList ExpList():{  Exp e;  ExpList el;}{  e = Exp() el = ExpList2()  {    el.addElement(e);    return el;  }|{  return new ExpList();}}ExpList ExpList2():{  Exp exp;  ExpList eList;}{  exp = ExpRight() eList = ExpList2()  {    eList.addElement(exp);    return eList;  }|{  return new ExpList();}}Exp ExpRight():{  Exp exp;}{  < COMMA > exp = Exp()  {    return exp;  }}